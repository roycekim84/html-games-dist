<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>룬도주</title>
  <style>
    :root{
      --bg0:#07080c;
      --bg1:#0b1020;
      --fg:#e9edf5;
      --muted:#aab3c5;
      --danger:#ff4d4d;
      --good:#7dffb2;
      --accent:#b07cff;
      --accent2:#2fe6ff;
      --panel:rgba(14,16,26,.72);
      --panel2:rgba(10,12,18,.55);
      --stroke:rgba(255,255,255,.10);
      --shadow:rgba(0,0,0,.55);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", sans-serif;
    }
    html,body{height:100%; margin:0; background: radial-gradient(1200px 700px at 50% 0%, #121a3a 0%, var(--bg0) 60%, #05060a 100%); color:var(--fg); font-family:var(--sans); overflow:hidden;}
    #app{position:fixed; inset:0; display:flex; flex-direction:column;}
    #game{position:absolute; inset:0; width:100%; height:100%; display:block;}
    #ui{position:absolute; inset:0; pointer-events:none;}
    .topbar{position:absolute; top:12px; left:12px; right:12px; display:flex; gap:12px; align-items:flex-start; justify-content:space-between; pointer-events:none;}
    .hud{display:flex; gap:10px; flex-wrap:wrap; pointer-events:none;}
    .chip{pointer-events:none; display:flex; align-items:center; gap:8px; padding:10px 12px; border-radius:999px; background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04)); border:1px solid var(--stroke); box-shadow:0 8px 24px var(--shadow); backdrop-filter: blur(10px);}
    .chip b{font-weight:800; letter-spacing:.2px;}
    .chip .k{font-family:var(--mono); font-size:12px; color:var(--muted);}
    .chip .v{font-family:var(--mono); font-size:13px;}
    .hpbar{display:flex; gap:6px; align-items:center;}
    .heart{width:12px; height:12px; border-radius:3px; transform:rotate(45deg); background:rgba(255,255,255,.15); border:1px solid rgba(255,255,255,.18); box-shadow:0 0 16px rgba(255,80,80,.18);}
    .heart.on{background:linear-gradient(135deg, #ff4d6d, #ff8a4d); border-color:rgba(255,255,255,.22); box-shadow:0 0 18px rgba(255,80,80,.35);}
    .heart::before,.heart::after{content:""; position:absolute; width:12px; height:12px; border-radius:50%; background:inherit; border:inherit; box-sizing:border-box;}
    .heart::before{top:-7px; left:0;}
    .heart::after{top:0; left:-7px;}
    .rightBtns{display:flex; gap:10px; pointer-events:auto;}
    .btn{pointer-events:auto; user-select:none; -webkit-tap-highlight-color:transparent; cursor:pointer; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,.03)); color:var(--fg); padding:10px 12px; border-radius:999px; display:flex; align-items:center; gap:8px; box-shadow:0 10px 24px var(--shadow); backdrop-filter: blur(10px); font-weight:700;}
    .btn:active{transform:translateY(1px);}
    .btn .dot{width:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.35); box-shadow:0 0 0 2px rgba(255,255,255,.08);}
    .btn .dot.on{background:var(--good); box-shadow:0 0 0 2px rgba(125,255,178,.18), 0 0 18px rgba(125,255,178,.35);}
    .btn .dot.off{background:rgba(255,255,255,.25);}
    .legend{position:absolute; bottom:14px; left:14px; padding:12px 14px; border-radius:var(--radius); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid var(--stroke); box-shadow:0 12px 28px var(--shadow); backdrop-filter: blur(10px); max-width:min(520px, calc(100vw - 28px)); pointer-events:none;}
    .legend .t{font-weight:900; letter-spacing:.2px; margin-bottom:6px;}
    .legend .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center; color:var(--muted); font-size:13px;}
    .kbd{font-family:var(--mono); font-size:12px; color:var(--fg); padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25);}
    .toast{position:absolute; top:86px; left:50%; transform:translateX(-50%); padding:10px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.45); box-shadow:0 12px 24px rgba(0,0,0,.55); backdrop-filter: blur(10px); color:var(--fg); font-weight:800; letter-spacing:.2px; opacity:0; transition:opacity .18s ease, transform .18s ease; pointer-events:none;}
    .toast.show{opacity:1; transform:translateX(-50%) translateY(0);}
    .centerOverlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; padding:18px; pointer-events:none;}
    .panel{pointer-events:auto; width:min(680px, 92vw); border-radius:24px; border:1px solid rgba(255,255,255,.12); background:linear-gradient(180deg, rgba(16,18,30,.80), rgba(8,10,18,.70)); box-shadow:0 24px 80px rgba(0,0,0,.75); backdrop-filter: blur(14px); padding:18px;}
    .panel header{display:flex; justify-content:space-between; align-items:flex-start; gap:12px;}
    .title{font-size:22px; font-weight:1000; letter-spacing:.2px; remind: 0;}
    .subtitle{margin-top:4px; color:var(--muted); line-height:1.35;}
    .grid{margin-top:14px; display:grid; grid-template-columns:1.4fr 1fr; gap:12px;}
    @media (max-width: 680px){ .grid{grid-template-columns:1fr;} }
    .card{border-radius:18px; border:1px solid rgba(255,255,255,.10); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); padding:14px;}
    .card h3{margin:0 0 8px 0; font-size:13px; letter-spacing:.3px; color:rgba(255,255,255,.85); text-transform:uppercase;}
    .card p{margin:0; color:var(--muted); font-size:13px; line-height:1.45;}
    .card .kv{margin-top:10px; display:flex; flex-wrap:wrap; gap:8px;}
    .pill{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.22); font-family:var(--mono); font-size:12px; color:rgba(255,255,255,.86);}
    .actions{margin-top:14px; display:flex; gap:10px; flex-wrap:wrap;}
    .primary{background:linear-gradient(180deg, rgba(176,124,255,.28), rgba(176,124,255,.10)); border-color:rgba(176,124,255,.35);}
    .danger{background:linear-gradient(180deg, rgba(255,77,77,.22), rgba(255,77,77,.08)); border-color:rgba(255,77,77,.30);}
    .ghost{background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));}
    .muted{color:var(--muted);}
    .creditsModal{position:absolute; inset:0; display:none; align-items:center; justify-content:center; padding:18px; pointer-events:auto;}
    .creditsModal.show{display:flex;}
    .creditsBody{margin-top:10px; color:var(--muted); font-size:13px; line-height:1.5;}
    .creditsBody a{color:rgba(47,230,255,.92); text-decoration:none; border-bottom:1px solid rgba(47,230,255,.35);}
    .creditsBody a:hover{opacity:.9;}
    .tiny{font-size:12px; color:rgba(255,255,255,.65);}
    .srOnly{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0;}
  </style>
</head>
<body>
  <div id="app">
    <canvas id="game" aria-label="룬도주 게임 화면" role="img"></canvas>
    <div id="ui">
      <div class="topbar">
        <div class="hud" aria-live="polite">
          <div class="chip"><span class="k">SCORE</span><b class="v" id="score">0</b></div>
          <div class="chip"><span class="k">TIME</span><b class="v" id="time">0.0s</b></div>
          <div class="chip"><span class="k">LEVEL</span><b class="v" id="level">1</b></div>
          <div class="chip"><span class="k">HP</span><div class="hpbar" id="hpbar"></div></div>
          <div class="chip"><span class="k">COMBO</span><b class="v" id="combo">—</b></div>
          <div class="chip"><span class="k">BEST</span><b class="v" id="best">0</b></div>
        </div>
        <div class="rightBtns">
          <button class="btn" id="btnMute" type="button" aria-label="사운드 토글"><span class="dot on" id="muteDot"></span><span id="muteText">SFX</span></button>
          <button class="btn" id="btnCredits" type="button" aria-label="크레딧 보기">Credits</button>
        </div>
      </div>

      <div class="toast" id="toast" role="status" aria-live="polite"></div>

      <div class="legend" aria-hidden="true">
        <div class="t">조작</div>
        <div class="row">
          <span><span class="kbd">←</span><span class="kbd">→</span> / <span class="kbd">A</span><span class="kbd">D</span> 이동</span>
          <span><span class="kbd">Shift</span> 도주(회피)</span>
          <span><span class="kbd">Space</span> 시작/일시정지</span>
          <span><span class="kbd">R</span> 재시작</span>
        </div>
        <div class="row" style="margin-top:6px;">
          <span class="tiny">모바일: 화면 하단 드래그 이동 · 두 번 탭(또는 긴 탭) 도주 · 한 번 탭 일시정지</span>
        </div>
      </div>

      <div class="centerOverlay" id="overlayRoot">
        <div class="panel" id="panel" style="display:none;">
          <header>
            <div>
              <div class="title" id="panelTitle">룬도주</div>
              <div class="subtitle" id="panelSubtitle">어둠의 신전에서 살아남아라.</div>
            </div>
            <div class="muted tiny" id="panelHint">키보드 중심</div>
          </header>
          <div class="grid">
            <div class="card">
              <h3>목표</h3>
              <p>장애물과 부패한 존재를 피하고, 룬과 보상을 모아 생존 시간을 최대화하세요. 시간이 지날수록 적은 더 빠르고 더 자주 등장합니다.</p>
              <div class="kv">
                <span class="pill">점수 = 생존시간 기반</span>
                <span class="pill">콤보 = 표시용</span>
                <span class="pill">레벨 = 시간 구간</span>
              </div>
            </div>
            <div class="card">
              <h3>도주(Shift)</h3>
              <p>짧은 순간, 그림자 속으로 미끄러지며 무적에 가까운 회피를 합니다. 연속 사용은 불가하며 쿨다운이 존재합니다.</p>
              <div class="kv">
                <span class="pill">무적: 짧게</span>
                <span class="pill">쿨다운: 점진</span>
              </div>
            </div>
          </div>
          <div class="actions">
            <button class="btn primary" id="btnStart" type="button">Space로 시작</button>
            <button class="btn ghost" id="btnResume" type="button" style="display:none;">Space로 계속</button>
            <button class="btn danger" id="btnRestart" type="button">R로 재시작</button>
          </div>
          <div class="tiny muted" style="margin-top:10px;">
            탭 전환(포커스 이탈) 시 자동 일시정지됩니다.
          </div>
        </div>
      </div>

      <div class="creditsModal" id="creditsModal" role="dialog" aria-modal="true" aria-labelledby="creditsTitle">
        <div class="panel">
          <header>
            <div>
              <div class="title" id="creditsTitle">Credits</div>
              <div class="subtitle">출처/라이선스 정보</div>
            </div>
            <button class="btn" id="btnCloseCredits" type="button" aria-label="크레딧 닫기">닫기</button>
          </header>
          <div class="creditsBody">
            <p><b>외부 자원 사용:</b> 없음</p>
            <p>그래픽: Canvas에 의해 절차적으로(프로시저럴) 생성</p>
            <p>사운드: WebAudio 합성(오실레이터/노이즈/필터) 기반</p>
            <p class="tiny">외부 이미지/폰트/사운드 파일을 로드하지 않습니다. 필요 시 정책에 따라 이 화면에 출처/링크/라이선스를 추가합니다.</p>
          </div>
        </div>
      </div>

      <div class="srOnly" id="a11yAnnounce" aria-live="polite"></div>
    </div>
  </div>

  <script>
    "use strict";
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });

    const $ = (id) => document.getElementById(id);
    const uiScore = $("score");
    const uiTime = $("time");
    const uiLevel = $("level");
    const uiCombo = $("combo");
    const uiBest = $("best");
    const hpbar = $("hpbar");
    const toast = $("toast");
    const overlayRoot = $("overlayRoot");
    const panel = $("panel");
    const panelTitle = $("panelTitle");
    const panelSubtitle = $("panelSubtitle");
    const btnStart = $("btnStart");
    const btnResume = $("btnResume");
    const btnRestart = $("btnRestart");
    const btnMute = $("btnMute");
    const muteDot = $("muteDot");
    const muteText = $("muteText");
    const btnCredits = $("btnCredits");
    const creditsModal = $("creditsModal");
    const btnCloseCredits = $("btnCloseCredits");
    const a11yAnnounce = $("a11yAnnounce");

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function randi(a,b){ return (a + Math.floor(Math.random()*(b-a+1))); }
    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
    function now(){ return performance.now(); }

    const storage = (() => {
      let mem = {};
      try{
        const k = "__rundoju_test__";
        localStorage.setItem(k, "1");
        localStorage.removeItem(k);
        return {
          get: (key, def) => {
            try{
              const v = localStorage.getItem(key);
              return v == null ? def : JSON.parse(v);
            }catch(_){ return def; }
          },
          set: (key, val) => {
            try{ localStorage.setItem(key, JSON.stringify(val)); }catch(_){}
          }
        };
      }catch(_){
        return {
          get: (key, def) => (key in mem ? mem[key] : def),
          set: (key, val) => { mem[key] = val; }
        };
      }
    })();

    let W=0,H=0, DPR=1;
    let safeTop=0, safeBottom=0, safeLeft=0, safeRight=0;

    function resize(){
      const r = canvas.getBoundingClientRect();
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.max(320, Math.floor(r.width));
      H = Math.max(320, Math.floor(r.height));
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      const vv = window.visualViewport;
      const insetTop = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("env(safe-area-inset-top)"))||0);
      const insetBottom = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("env(safe-area-inset-bottom)"))||0);
      const insetLeft = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("env(safe-area-inset-left)"))||0);
      const insetRight = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("env(safe-area-inset-right)"))||0);
      safeTop = insetTop;
      safeBottom = insetBottom;
      safeLeft = insetLeft;
      safeRight = insetRight;
      if(vv){
        const padBottom = Math.max(0, (window.innerHeight - vv.height - vv.offsetTop));
        safeBottom = Math.max(safeBottom, padBottom);
      }
      world.recalc();
    }
    window.addEventListener("resize", resize, { passive:true });

    const input = {
      left:false, right:false, up:false, down:false,
      dodge:false,
      pause:false,
      restart:false,
      any:false,
      _dodgeDown:false,
      _pauseDown:false,
      _restartDown:false
    };

    const keyMap = {
      "ArrowLeft":"left","KeyA":"left",
      "ArrowRight":"right","KeyD":"right",
      "ArrowUp":"up","KeyW":"up",
      "ArrowDown":"down","KeyS":"down"
    };

    function setKey(e, down){
      const code = e.code || e.key;
      if(code in keyMap){
        input[keyMap[code]] = down;
        input.any = true;
        e.preventDefault();
      }else if(code === "ShiftLeft" || code === "ShiftRight"){
        if(down && !input._dodgeDown){ input.dodge = true; input._dodgeDown = true; }
        if(!down){ input._dodgeDown = false; }
        input.any = true;
        e.preventDefault();
      }else if(code === "Space"){
        if(down && !input._pauseDown){ input.pause = true; input._pauseDown = true; }
        if(!down){ input._pauseDown = false; }
        input.any = true;
        e.preventDefault();
      }else if(code === "KeyR"){
        if(down && !input._restartDown){ input.restart = true; input._restartDown = true; }
        if(!down){ input._restartDown = false; }
        input.any = true;
        e.preventDefault();
      }
    }

    window.addEventListener("keydown", (e)=>setKey(e,true), { passive:false });
    window.addEventListener("keyup", (e)=>setKey(e,false), { passive:false });

    const touch = {
      active:false,
      id:null,
      startX:0,
      startY:0,
      lastX:0,
      lastY:0,
      lastTapT:0,
      tapCount:0,
      holdT:0
    };

    function onPointerDown(e){
      if(e.pointerType === "mouse") return;
      if(creditsModal.classList.contains("show")) return;
      touch.active = true;
      touch.id = e.pointerId;
      touch.startX = e.clientX;
      touch.startY = e.clientY;
      touch.lastX = e.clientX;
      touch.lastY = e.clientY;
      touch.holdT = now();
      const t = now();
      if(t - touch.lastTapT < 320){
        touch.tapCount++;
      }else{
        touch.tapCount = 1;
      }
      touch.lastTapT = t;
      canvas.setPointerCapture(e.pointerId);
      e.preventDefault();
    }
    function onPointerMove(e){
      if(!touch.active || e.pointerId !== touch.id) return;
      touch.lastX = e.clientX;
      touch.lastY = e.clientY;
      const dx = touch.lastX - touch.startX;
      const dy = touch.lastY - touch.startY;
      const bottomZone = (touch.startY > window.innerHeight * 0.55);
      if(bottomZone){
        input.left = dx < -10;
        input.right = dx > 10;
        input.any = true;
      }
      e.preventDefault();
    }
    function onPointerUp(e){
      if(!touch.active || e.pointerId !== touch.id) return;
      const t = now();
      const dt = t - touch.holdT;
      const moved = Math.hypot(touch.lastX - touch.startX, touch.lastY - touch.startY) > 18;
      input.left = false; input.right = false;
      if(!moved){
        if(touch.tapCount >= 2 || dt > 520){
          input.dodge = true;
          input.any = true;
          touch.tapCount = 0;
        }else{
          input.pause = true;
          input.any = true;
        }
      }
      touch.active = false;
      touch.id = null;
      e.preventDefault();
    }
    canvas.addEventListener("pointerdown", onPointerDown, { passive:false });
    canvas.addEventListener("pointermove", onPointerMove, { passive:false });
    canvas.addEventListener("pointerup", onPointerUp, { passive:false });
    canvas.addEventListener("pointercancel", onPointerUp, { passive:false });

    document.addEventListener("visibilitychange", () => {
      if(document.hidden) game.setPaused(true, "포커스 이탈");
    });

    const audio = (() => {
      let ac = null;
      let master = null;
      let sfxGain = null;
      let muted = false;
      let unlocked = false;

      function ensure(){
        if(ac) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if(!AudioContext) return;
        ac = new AudioContext();
        master = ac.createGain();
        sfxGain = ac.createGain();
        master.gain.value = 0.9;
        sfxGain.gain.value = 0.7;
        sfxGain.connect(master);
        master.connect(ac.destination);
      }

      function resume(){
        ensure();
        if(!ac) return;
        if(ac.state === "suspended") ac.resume();
        unlocked = true;
      }

      function setMuted(v){
        muted = !!v;
        if(sfxGain) sfxGain.gain.value = muted ? 0 : 0.7;
        muteDot.classList.toggle("on", !muted);
        muteDot.classList.toggle("off", muted);
        muteText.textContent = muted ? "MUTED" : "SFX";
      }

      function tone({f=220, t=0.08, type="sine", g=0.12, bend=0, noise=0}){
        if(!unlocked) return;
        ensure();
        if(!ac || muted) return;
        const start = ac.currentTime;
        const end = start + t;

        const out = ac.createGain();
        out.gain.setValueAtTime(0.0001, start);
        out.gain.exponentialRampToValueAtTime(Math.max(0.0001, g), start + Math.min(0.02, t*0.3));
        out.gain.exponentialRampToValueAtTime(0.0001, end);

        const osc = ac.createOscillator();
        osc.type = type;
        osc.frequency.setValueAtTime(f, start);
        if(bend !== 0){
          osc.frequency.exponentialRampToValueAtTime(Math.max(40, f * (1 + bend)), end);
        }
        osc.connect(out);

        let mix = out;

        if(noise > 0){
          const n = ac.createBufferSource();
          const len = Math.floor(ac.sampleRate * t);
          const buf = ac.createBuffer(1, len, ac.sampleRate);
          const data = buf.getChannelData(0);
          for(let i=0;i<len;i++){
            const x = Math.random()*2-1;
            data[i] = x * noise;
          }
          n.buffer = buf;
          const nf = ac.createBiquadFilter();
          nf.type = "bandpass";
          nf.frequency.value = f*2;
          nf.Q.value = 0.9;
          const ng = ac.createGain();
          ng.gain.value = 0.55;
          n.connect(nf); nf.connect(ng); ng.connect(out);
          n.start(start);
          n.stop(end);
        }

        mix.connect(sfxGain);
        osc.start(start);
        osc.stop(end);
      }

      function whoosh(){
        tone({f:240, t:0.12, type:"triangle", g:0.16, bend:-0.45, noise:0.06});
      }
      function hit(){
        tone({f:110, t:0.10, type:"square", g:0.14, bend:-0.65, noise:0.10});
        setTimeout(()=>tone({f:160, t:0.06, type:"sawtooth", g:0.08, bend:-0.25, noise:0.04}), 10);
      }
      function pickup(){
        tone({f:520, t:0.07, type:"sine", g:0.14, bend:0.12, noise:0.02});
        setTimeout(()=>tone({f:740, t:0.06, type:"sine", g:0.10, bend:0.08, noise:0.01}), 14);
      }
      function portal(){
        tone({f:180, t:0.16, type:"sawtooth", g:0.10, bend:0.35, noise:0.06});
      }
      function step(){
        tone({f:90, t:0.035, type:"triangle", g:0.05, bend:-0.08, noise:0.08});
      }

      return { resume, setMuted, whoosh, hit, pickup, portal, step, get muted(){ return muted; }, get ok(){ return !!(window.AudioContext||window.webkitAudioContext); } };
    })();

    btnMute.addEventListener("click", () => {
      audio.resume();
      audio.setMuted(!audio.muted);
      toastMsg(audio.muted ? "사운드 꺼짐" : "사운드 켜짐");
    });

    btnCredits.addEventListener("click", () => {
      audio.resume();
      creditsModal.classList.add("show");
    });
    btnCloseCredits.addEventListener("click", () => creditsModal.classList.remove("show"));
    creditsModal.addEventListener("click", (e) => {
      if(e.target === creditsModal) creditsModal.classList.remove("show");
    });

    function toastMsg(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>toast.classList.remove("show"), 900);
    }

    const world = {
      lanes: 5,
      laneX: [],
      roadLeft: 0,
      roadRight: 0,
      roadW: 0,
      groundY: 0,
      horizonY: 0,
      scale: 1,
      recalc(){
        const minDim = Math.min(W,H);
        this.scale = clamp(minDim / 720, 0.8, 1.25);
        const pad = Math.max(14, Math.floor(22 * this.scale));
        const side = Math.max(pad + safeLeft, pad + safeRight);
        const roadW = clamp(W * 0.64, 320, 720) * this.scale * clamp(W/900, 0.9, 1.15);
        const cx = W * 0.5;
        this.roadW = roadW;
        this.roadLeft = cx - roadW*0.5;
        this.roadRight = cx + roadW*0.5;
        this.groundY = H * 0.82;
        this.horizonY = H * 0.28;
        this.laneX.length = 0;
        for(let i=0;i<this.lanes;i++){
          const t = (i + 0.5) / this.lanes;
          this.laneX.push(lerp(this.roadLeft, this.roadRight, t));
        }
      }
    };

    const pool = {
      _p: new Map(),
      get(type){
        const a = this._p.get(type);
        if(a && a.length) return a.pop();
        return null;
      },
      put(type, obj){
        if(!this._p.has(type)) this._p.set(type, []);
        this._p.get(type).push(obj);
      }
    };

    function makeParticle(){
      return {x:0,y:0,vx:0,vy:0,life:0,age:0,size:1,kind:0,rot:0,vr:0,alpha:1,glow:0};
    }

    const fx = {
      particles: [],
      flashes: [],
      shakeT: 0,
      shakeA: 0,
      portalPhase: 0,
      portalPulse: 0,
      vignette: 0.55,
      spawnBurst(x,y, n, kind){
        for(let i=0;i<n;i++){
          const p = pool.get("p") || makeParticle();
          p.x = x; p.y = y;
          const a = rand(0, Math.PI*2);
          const sp = rand(40, 240) * world.scale;
          p.vx = Math.cos(a)*sp;
          p.vy = Math.sin(a)*sp - rand(0, 60)*world.scale;
          p.life = rand(0.30, 0.75);
          p.age = 0;
          p.size = rand(1.5, 4.2) * world.scale;
          p.kind = kind;
          p.rot = rand(0, Math.PI*2);
          p.vr = rand(-8, 8);
          p.alpha = 1;
          p.glow = rand(0.2, 0.9);
          this.particles.push(p);
        }
      },
      ring(x,y, r0, r1, t){
        this.flashes.push({x,y,r0,r1,t,age:0});
      },
      shake(a, t){
        this.shakeA = Math.max(this.shakeA, a);
        this.shakeT = Math.max(this.shakeT, t);
      }
    };

    const defs = {
      obstacleTypes: [
        { id:"spike", minLvl:1, w: 1.0 },
        { id:"wall", minLvl:1, w: 0.9 },
        { id:"rock", minLvl:2, w: 0.8 },
        { id:"vine", minLvl:3, w: 0.85 }
      ],
      enemyTypes: [
        { id:"shadowElite", minLvl:1, w: 1.0 },
        { id:"wraith", minLvl:2, w: 0.9 },
        { id:"vortexOrb", minLvl:3, w: 0.8 }
      ],
      itemTypes: [
        { id:"rune", minLvl:1, w: 1.0 },
        { id:"coin", minLvl:1, w: 1.1 },
        { id:"potion", minLvl:2, w: 0.65 },
        { id:"timeRelic", minLvl:2, w: 0.75 }
      ]
    };

    function pickWeighted(list, lvl){
      let sum = 0;
      for(const it of list){
        if(lvl >= it.minLvl) sum += it.w;
      }
      let r = Math.random() * sum;
      for(const it of list){
        if(lvl < it.minLvl) continue;
        r -= it.w;
        if(r <= 0) return it.id;
      }
      return list[0].id;
    }

    function AABB(a,b){
      return (Math.abs(a.x-b.x) * 2 < (a.w + b.w)) && (Math.abs(a.y-b.y) * 2 < (a.h + b.h));
    }

    function fmt1(x){ return (Math.round(x*10)/10).toFixed(1); }

    const game = {
      state: "boot",
      running: false,
      paused: false,
      gameOver: false,
      started: false,
      t: 0,
      score: 0,
      best: 0,
      hp: 3,
      lvl: 1,
      comboPlaceholder: "—",
      lastStep: 0,
      pauseReason: "",
      setState(s){
        this.state = s;
      },
      setPaused(p, reason){
        if(this.gameOver) return;
        if(!this.started) return;
        if(p){
          if(!this.paused){
            this.paused = true;
            this.pauseReason = reason || "일시정지";
            showPanel("paused");
            toastMsg(this.pauseReason);
            a11yAnnounce.textContent = "일시정지";
          }
        }else{
          if(this.paused){
            this.paused = false;
            hidePanel();
            toastMsg("재개");
            a11yAnnounce.textContent = "재개";
          }
        }
      },
      start(){
        audio.resume();
        if(!this.started){
          resetRun();
          this.started = true;
          this.paused = false;
          this.gameOver = false;
          hidePanel();
          toastMsg("룬도주 시작");
          a11yAnnounce.textContent = "게임 시작";
          audio.portal();
        }else if(this.paused){
          this.setPaused(false);
        }
      },
      restart(){
        audio.resume();
        resetRun();
        this.started = true;
        this.paused = false;
        this.gameOver = false;
        hidePanel();
        toastMsg("재시작");
        a11yAnnounce.textContent = "재시작";
        audio.portal();
      },
      die(){
        this.gameOver = true;
        this.paused = true;
        showPanel("gameover");
        audio.hit();
        fx.shake(12*world.scale, 0.28);
        a11yAnnounce.textContent = "게임 오버";
      }
    };

    btnStart.addEventListener("click", () => game.start());
    btnResume.addEventListener("click", () => game.start());
    btnRestart.addEventListener("click", () => game.restart());

    function showPanel(mode){
      panel.style.display = "block";
      if(mode === "intro"){
        panelTitle.textContent = "룬도주";
        panelSubtitle.textContent = "어둠의 신전, 부패한 마력의 길을 질주하라. Space로 시작.";
        btnStart.style.display = "";
        btnResume.style.display = "none";
      }else if(mode === "paused"){
        panelTitle.textContent = "일시정지";
        panelSubtitle.textContent = "Space로 재개. R로 재시작.";
        btnStart.style.display = "none";
        btnResume.style.display = "";
      }else if(mode === "gameover"){
        panelTitle.textContent = "실패";
        panelSubtitle.textContent = `HP가 0이 되었습니다. 생존 ${fmt1(game.t)}s · 점수 ${Math.floor(game.score)}. R로 재시작.`;
        btnStart.style.display = "none";
        btnResume.style.display = "none";
      }
    }
    function hidePanel(){ panel.style.display = "none"; }

    const entities = {
      obstacles: [],
      enemies: [],
      items: [],
      hazardFX: []
    };

    function makeEntity(type){
      return {type, x:0,y:0,w:20,h:20,vx:0,vy:0,life:1,age:0,kind:"",lane:0,phase:0,seed:Math.random()*9999,alpha:1,hit:false,tag:0,cd:0};
    }

    const player = {
      x:0, y:0, w:28, h:38,
      lane:2,
      targetLane:2,
      speedLane: 11,
      hp:3,
      invul: 0,
      dodgeT: 0,
      dodgeCD: 0,
      edgeBump: 0,
      aura: 0
    };

    const spawner = {
      baseSpeed: 360,
      speed: 360,
      spawnTimer: 0,
      spawnEvery: 0.85,
      itemTimer: 0,
      itemEvery: 1.15,
      enemyTimer: 0,
      enemyEvery: 1.25,
      difficulty: 0,
      lastObstacleLane: -1,
      lastEnemyLane: -1,
      reset(){
        this.baseSpeed = 360;
        this.speed = 360;
        this.spawnTimer = 0;
        this.spawnEvery = 0.86;
        this.itemTimer = 0;
        this.itemEvery = 1.18;
        this.enemyTimer = 0;
        this.enemyEvery = 1.28;
        this.difficulty = 0;
        this.lastObstacleLane = -1;
        this.lastEnemyLane = -1;
      }
    };

    function levelFromTime(t){
      if(t < 30) return 1;
      if(t < 60) return 2;
      if(t < 90) return 3;
      if(t < 120) return 4;
      return 5;
    }

    function updateDifficulty(dt){
      const lvl = levelFromTime(game.t);
      game.lvl = lvl;

      const base = 1 + (game.t / 140);
      const lvlBoost = 1 + (lvl-1) * 0.08;
      spawner.difficulty = clamp(base*lvlBoost, 1, 3.2);

      const targetSpeed = spawner.baseSpeed * spawner.difficulty;
      spawner.speed = lerp(spawner.speed, targetSpeed, clamp(dt*0.8, 0, 1));

      const targetSpawnEvery = clamp(0.92 / spawner.difficulty, 0.32, 0.92);
      const targetEnemyEvery = clamp(1.25 / (0.9 + (spawner.difficulty-1)*0.95), 0.42, 1.25);
      const targetItemEvery = clamp(1.15 / (1 + (spawner.difficulty-1)*0.35), 0.55, 1.15);

      spawner.spawnEvery = lerp(spawner.spawnEvery, targetSpawnEvery, clamp(dt*0.65,0,1));
      spawner.enemyEvery = lerp(spawner.enemyEvery, targetEnemyEvery, clamp(dt*0.60,0,1));
      spawner.itemEvery = lerp(spawner.itemEvery, targetItemEvery, clamp(dt*0.55,0,1));
    }

    function resetRun(){
      entities.obstacles.length = 0;
      entities.enemies.length = 0;
      entities.items.length = 0;
      entities.hazardFX.length = 0;
      fx.particles.length = 0;
      fx.flashes.length = 0;
      fx.shakeT = 0;
      fx.shakeA = 0;
      fx.portalPulse = 0;
      fx.portalPhase = 0;

      game.t = 0;
      game.score = 0;
      game.hp = 3;
      player.hp = 3;
      player.invul = 0;
      player.dodgeT = 0;
      player.dodgeCD = 0;
      player.edgeBump = 0;
      player.aura = 0;
      player.lane = Math.floor(world.lanes/2);
      player.targetLane = player.lane;

      spawner.reset();

      game.comboPlaceholder = "—";
      game.lastStep = 0;

      uiCombo.textContent = game.comboPlaceholder;

      game.best = storage.get("rundoju_best", 0) || 0;
      uiBest.textContent = String(game.best);

      buildHP();
    }

    function buildHP(){
      hpbar.innerHTML = "";
      for(let i=0;i<3;i++){
        const d = document.createElement("div");
        d.className = "heart" + (i < game.hp ? " on" : "");
        hpbar.appendChild(d);
      }
    }
    function setHP(v){
      game.hp = clamp(v, 0, 3);
      buildHP();
      if(game.hp <= 0){
        game.die();
        updateBest();
      }
    }

    function updateBest(){
      const s = Math.floor(game.score);
      if(s > game.best){
        game.best = s;
        storage.set("rundoju_best", game.best);
        uiBest.textContent = String(game.best);
        toastMsg("최고 기록 갱신");
      }
    }

    function playerHit(dmg){
      if(player.invul > 0 || player.dodgeT > 0) return;
      setHP(game.hp - dmg);
      player.invul = 0.9;
      fx.shake(10*world.scale, 0.22);
      fx.spawnBurst(player.x, player.y, 18, 2);
      fx.ring(player.x, player.y, 6*world.scale, 52*world.scale, 0.18);
      audio.hit();
    }

    function awardItem(kind){
      let bonusScore = 0;
      let bonusTime = 0;
      if(kind === "rune"){ bonusScore = 35; bonusTime = 0.4; }
      if(kind === "coin"){ bonusScore = 18; bonusTime = 0.15; }
      if(kind === "potion"){
        if(game.hp < 3){ setHP(game.hp + 1); toastMsg("생명 +1"); }
        else{ bonusScore = 22; toastMsg("포션: 점수"); }
      }
      if(kind === "timeRelic"){ bonusScore = 25; bonusTime = 1.6; toastMsg("시간 증강 +1.6s"); }
      game.score += bonusScore;
      game.t += bonusTime;
      player.aura = Math.max(player.aura, 0.22);
      fx.spawnBurst(player.x, player.y, 14, 1);
      audio.pickup();
      game.comboPlaceholder = "—";
      uiCombo.textContent = game.comboPlaceholder;
    }

    function spawnObstacle(){
      const e = pool.get("o") || makeEntity("obstacle");
      e.type = "obstacle";
      e.age = 0;
      e.hit = false;
      e.alpha = 1;
      e.tag = 0;
      e.cd = 0;
      e.kind = pickWeighted(defs.obstacleTypes, game.lvl);

      let lane = randi(0, world.lanes-1);
      if(Math.random() < 0.58 && spawner.lastObstacleLane >= 0){
        if(Math.random() < 0.55){
          const d = (Math.random() < 0.5 ? -1 : 1);
          lane = clamp(spawner.lastObstacleLane + d, 0, world.lanes-1);
        }
      }
      spawner.lastObstacleLane = lane;
      e.lane = lane;
      e.x = world.laneX[lane];
      e.y = world.horizonY - 28*world.scale;
      const s = world.scale;
      if(e.kind === "spike"){ e.w = 44*s; e.h = 34*s; }
      if(e.kind === "wall"){ e.w = 66*s; e.h = 58*s; }
      if(e.kind === "rock"){ e.w = 52*s; e.h = 48*s; e.vy = rand(20, 60)*s; }
      if(e.kind === "vine"){ e.w = 58*s; e.h = 42*s; e.phase = rand(0, Math.PI*2); }
      entities.obstacles.push(e);
      fx.portalPulse = Math.min(1, fx.portalPulse + 0.10);
      if(Math.random() < 0.25) audio.portal();
    }

    function spawnEnemy(){
      const e = pool.get("e") || makeEntity("enemy");
      e.type = "enemy";
      e.age = 0;
      e.hit = false;
      e.alpha = 1;
      e.cd = 0;
      e.kind = pickWeighted(defs.enemyTypes, game.lvl);

      let lane = randi(0, world.lanes-1);
      if(spawner.lastEnemyLane >= 0 && Math.random() < 0.45){
        lane = clamp(spawner.lastEnemyLane + (Math.random()<0.5?-1:1), 0, world.lanes-1);
      }
      spawner.lastEnemyLane = lane;
      e.lane = lane;
      e.x = world.laneX[lane];
      e.y = world.horizonY - 40*world.scale;

      const s = world.scale;
      if(e.kind === "shadowElite"){ e.w = 40*s; e.h = 50*s; e.phase = rand(0, 999); }
      if(e.kind === "wraith"){ e.w = 44*s; e.h = 52*s; e.phase = rand(0, Math.PI*2); }
      if(e.kind === "vortexOrb"){ e.w = 40*s; e.h = 40*s; e.phase = rand(0, Math.PI*2); e.cd = rand(0.35, 0.9); }
      entities.enemies.push(e);
      fx.portalPulse = Math.min(1, fx.portalPulse + 0.12);
      audio.portal();
    }

    function spawnItem(){
      const e = pool.get("i") || makeEntity("item");
      e.type = "item";
      e.age = 0;
      e.hit = false;
      e.alpha = 1;
      e.kind = pickWeighted(defs.itemTypes, game.lvl);

      let lane = randi(0, world.lanes-1);
      if(Math.random() < 0.60 && player.targetLane != null){
        if(Math.random() < 0.55) lane = player.targetLane;
      }
      e.lane = lane;
      e.x = world.laneX[lane] + rand(-6,6)*world.scale;
      e.y = world.horizonY - 18*world.scale;
      const s = world.scale;
      if(e.kind === "rune"){ e.w=30*s; e.h=30*s; }
      if(e.kind === "coin"){ e.w=26*s; e.h=26*s; }
      if(e.kind === "potion"){ e.w=28*s; e.h=34*s; }
      if(e.kind === "timeRelic"){ e.w=32*s; e.h=32*s; }
      entities.items.push(e);
    }

    function despawn(list, idx, typeKey){
      const e = list[idx];
      list[idx] = list[list.length-1];
      list.pop();
      pool.put(typeKey, e);
    }

    function updatePlayer(dt){
      const s = world.scale;

      const left = input.left ? 1 : 0;
      const right = input.right ? 1 : 0;
      const dir = right - left;

      if(dir !== 0){
        player.targetLane = clamp(player.targetLane + dir, 0, world.lanes-1);
        input.left = false;
        input.right = false;
      }

      const targetX = world.laneX[player.targetLane];
      const laneSpeed = (player.dodgeT > 0 ? 20 : player.speedLane) * s;
      player.x = lerp(player.x, targetX, clamp(dt*laneSpeed, 0, 1));

      player.y = world.groundY - 40*s;

      player.w = 30*s;
      player.h = 46*s;

      if(player.invul > 0) player.invul = Math.max(0, player.invul - dt);
      if(player.dodgeT > 0) player.dodgeT = Math.max(0, player.dodgeT - dt);
      if(player.dodgeCD > 0) player.dodgeCD = Math.max(0, player.dodgeCD - dt);
      if(player.aura > 0) player.aura = Math.max(0, player.aura - dt);

      if(input.dodge){
        input.dodge = false;
        if(!game.paused && !game.gameOver && game.started){
          if(player.dodgeCD <= 0){
            player.dodgeT = 0.22;
            player.invul = Math.max(player.invul, 0.28);
            player.dodgeCD = clamp(0.85 - (game.lvl-1)*0.06, 0.55, 0.85);
            fx.shake(6*s, 0.16);
            fx.spawnBurst(player.x, player.y, 10, 0);
            fx.ring(player.x, player.y, 10*s, 80*s, 0.18);
            audio.whoosh();
            toastMsg("도주");
          }else{
            toastMsg("도주 대기");
          }
        }
      }

      if(!game.paused && game.started && !game.gameOver){
        if(game.t - game.lastStep > 0.26){
          game.lastStep = game.t;
          if(Math.random() < 0.65) audio.step();
        }
      }
    }

    function updateSpawns(dt){
      spawner.spawnTimer += dt;
      spawner.enemyTimer += dt;
      spawner.itemTimer += dt;

      const jitter = (v)=> v * rand(0.85, 1.18);

      while(spawner.spawnTimer >= spawner.spawnEvery){
        spawner.spawnTimer -= spawner.spawnEvery;
        spawnObstacle();
        if(Math.random() < 0.18 + (game.lvl-1)*0.03){
          if(Math.random() < 0.35) spawnObstacle();
        }
        spawner.spawnEvery = jitter(spawner.spawnEvery);
        spawner.spawnEvery = clamp(spawner.spawnEvery, 0.30, 0.95);
      }

      while(spawner.enemyTimer >= spawner.enemyEvery){
        spawner.enemyTimer -= spawner.enemyEvery;
        if(Math.random() < 0.72 + (game.lvl-1)*0.05){
          spawnEnemy();
          if(game.lvl >= 4 && Math.random() < 0.16) spawnEnemy();
        }
        spawner.enemyEvery = jitter(spawner.enemyEvery);
        spawner.enemyEvery = clamp(spawner.enemyEvery, 0.40, 1.30);
      }

      while(spawner.itemTimer >= spawner.itemEvery){
        spawner.itemTimer -= spawner.itemEvery;
        if(Math.random() < 0.86){
          spawnItem();
          if(game.lvl >= 3 && Math.random() < 0.22) spawnItem();
        }
        spawner.itemEvery = jitter(spawner.itemEvery);
        spawner.itemEvery = clamp(spawner.itemEvery, 0.55, 1.25);
      }
    }

    function updateEntities(dt){
      const speed = spawner.speed * dt * world.scale;
      const ground = world.groundY;

      for(let i=entities.obstacles.length-1;i>=0;i--){
        const e = entities.obstacles[i];
        e.age += dt;
        e.y += speed;

        if(e.kind === "rock"){
          e.y += (e.vy || 0) * dt * world.scale;
        }else if(e.kind === "vine"){
          e.x += Math.sin((game.t*3.2) + e.phase) * (18*world.scale) * dt;
        }

        const depth = clamp((e.y - world.horizonY) / (ground - world.horizonY), 0, 1);
        const perspective = lerp(0.55, 1.1, easeOutCubic(depth));
        e.w *= 1;
        e.h *= 1;
        e._px = e.x;
        e._py = e.y;
        e._ps = perspective;

        if(e.y > ground + 140*world.scale){
          despawn(entities.obstacles, i, "o");
        }
      }

      for(let i=entities.items.length-1;i>=0;i--){
        const e = entities.items[i];
        e.age += dt;
        e.y += speed * 0.92;
        e.phase += dt * 3.2;
        e.x += Math.sin(e.phase) * 10 * world.scale * dt;

        if(e.y > ground + 120*world.scale){
          despawn(entities.items, i, "i");
          continue;
        }
        if(!e.hit){
          const pbox = {x:player.x, y:player.y, w:player.w*0.85, h:player.h*0.85};
          const ebox = {x:e.x, y:e.y, w:e.w, h:e.h};
          if(AABB(pbox, ebox)){
            e.hit = true;
            awardItem(e.kind);
            fx.ring(e.x, e.y, 6*world.scale, 64*world.scale, 0.20);
            despawn(entities.items, i, "i");
          }
        }
      }

      for(let i=entities.enemies.length-1;i>=0;i--){
        const e = entities.enemies[i];
        e.age += dt;
        e.y += speed * (0.98 + (game.lvl-1)*0.02);

        if(e.kind === "shadowElite"){
          const tx = world.laneX[player.targetLane];
          e.x = lerp(e.x, tx, clamp(dt * (1.6 + (spawner.difficulty-1)*0.55), 0, 1));
        }else if(e.kind === "wraith"){
          e.x += Math.sin((game.t*2.6) + e.phase) * 54 * world.scale * dt;
        }else if(e.kind === "vortexOrb"){
          e.phase += dt * 2.8;
          e.x += Math.sin(e.phase) * 34 * world.scale * dt;
          e.cd -= dt;
          if(e.cd <= 0){
            e.cd = clamp(0.95 - (game.lvl-1)*0.10, 0.38, 0.95);
            spawnHazardOrb(e.x, e.y);
          }
        }

        if(e.y > ground + 150*world.scale){
          despawn(entities.enemies, i, "e");
          continue;
        }

        const pbox = {x:player.x, y:player.y, w:player.w*0.85, h:player.h*0.90};
        const ebox = {x:e.x, y:e.y, w:e.w, h:e.h};
        if(AABB(pbox, ebox)){
          playerHit(1);
          fx.spawnBurst(e.x, e.y, 10, 3);
          fx.ring(e.x, e.y, 8*world.scale, 70*world.scale, 0.18);
          despawn(entities.enemies, i, "e");
        }
      }

      for(let i=entities.hazardFX.length-1;i>=0;i--){
        const h = entities.hazardFX[i];
        h.age += dt;
        h.y += speed * 1.12;
        h.x += h.vx * dt;
        h.alpha = clamp(1 - h.age/h.life, 0, 1);
        if(h.age >= h.life || h.y > ground + 160*world.scale){
          entities.hazardFX[i] = entities.hazardFX[entities.hazardFX.length-1];
          entities.hazardFX.pop();
          pool.put("h", h);
          continue;
        }
        const pbox = {x:player.x, y:player.y, w:player.w*0.78, h:player.h*0.86};
        const hbox = {x:h.x, y:h.y, w:h.w, h:h.h};
        if(AABB(pbox, hbox)){
          playerHit(1);
          fx.spawnBurst(h.x, h.y, 12, 2);
          fx.ring(h.x, h.y, 10*world.scale, 72*world.scale, 0.20);
          h.age = h.life;
        }
      }
    }

    function spawnHazardOrb(x,y){
      const h = pool.get("h") || makeEntity("hazard");
      h.type = "hazard";
      h.kind = "orb";
      h.x = x;
      h.y = y;
      const s = world.scale;
      h.w = 22*s; h.h = 22*s;
      h.life = rand(1.4, 2.2);
      h.age = 0;
      h.vx = rand(-30, 30) * s;
      h.alpha = 1;
      entities.hazardFX.push(h);
      fx.portalPulse = Math.min(1, fx.portalPulse + 0.06);
      if(Math.random() < 0.35) audio.portal();
    }

    function updateFX(dt){
      fx.portalPhase += dt * (0.85 + (spawner.difficulty-1)*0.25);
      fx.portalPulse = Math.max(0, fx.portalPulse - dt*0.45);
      if(fx.shakeT > 0) fx.shakeT = Math.max(0, fx.shakeT - dt);
      if(fx.shakeT === 0) fx.shakeA = lerp(fx.shakeA, 0, clamp(dt*10,0,1));
      for(let i=fx.particles.length-1;i>=0;i--){
        const p = fx.particles[i];
        p.age += dt;
        if(p.age >= p.life){
          fx.particles[i] = fx.particles[fx.particles.length-1];
          fx.particles.pop();
          pool.put("p", p);
          continue;
        }
        p.vy += 380 * world.scale * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rot += p.vr * dt;
        p.alpha = clamp(1 - p.age/p.life, 0, 1);
      }
      for(let i=fx.flashes.length-1;i>=0;i--){
        const f = fx.flashes[i];
        f.age += dt;
        if(f.age >= f.t){
          fx.flashes[i] = fx.flashes[fx.flashes.length-1];
          fx.flashes.pop();
        }
      }
    }

    function draw(){
      ctx.save();

      let shakeX = 0, shakeY = 0;
      if(fx.shakeA > 0.01 && fx.shakeT > 0){
        const a = fx.shakeA * (fx.shakeT / Math.max(0.0001, fx.shakeT + 0.08));
        shakeX = (Math.random()*2-1) * a;
        shakeY = (Math.random()*2-1) * a;
        ctx.translate(shakeX, shakeY);
      }

      ctx.clearRect(0,0,W,H);

      drawBackground();
      drawRoad();
      drawPortals();
      drawEntitiesLayered();
      drawPlayer();
      drawFX();
      drawVignette();

      if(game.paused && game.started){
        ctx.save();
        ctx.globalAlpha = 0.20;
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      ctx.restore();
    }

    function drawBackground(){
      const t = game.t;
      const s = world.scale;

      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, "rgba(12,16,36,1)");
      g.addColorStop(0.35, "rgba(8,10,18,1)");
      g.addColorStop(1, "rgba(5,6,10,1)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      const starN = 80;
      ctx.save();
      ctx.globalAlpha = 0.65;
      for(let i=0;i<starN;i++){
        const seed = (i*997.7) % 1;
        const x = ((i*73.31) % 1) * W;
        const y = ((i*19.87) % 1) * (H*0.45);
        const tw = 0.35 + 0.65 * Math.sin(t*1.2 + i*1.7);
        const r = (0.7 + ((i*0.13)%1)*1.6) * s;
        ctx.globalAlpha = 0.12 + 0.18*tw;
        ctx.fillStyle = "rgba(180,210,255,1)";
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      const layers = [
        {y: world.horizonY + 16*s, a:0.24, sp: 10*s, k: 0},
        {y: world.horizonY + 44*s, a:0.18, sp: 18*s, k: 1},
        {y: world.horizonY + 78*s, a:0.14, sp: 26*s, k: 2},
      ];
      for(const L of layers){
        const off = (t*L.sp) % (W);
        ctx.save();
        ctx.globalAlpha = L.a;
        for(let x=-W; x<=W*2; x+= 140*s){
          const xx = x - off;
          drawRuinSilhouette(xx, L.y, 1.0 + L.k*0.08, s);
        }
        ctx.restore();
      }

      ctx.save();
      ctx.globalAlpha = 0.12;
      const fog = ctx.createRadialGradient(W*0.5, H*0.10, 0, W*0.5, H*0.40, W*0.80);
      fog.addColorStop(0, "rgba(176,124,255,0.12)");
      fog.addColorStop(0.45, "rgba(47,230,255,0.06)");
      fog.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = fog;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    function drawRuinSilhouette(x, y, scaleMul, s){
      const h = (70 + (Math.sin(x*0.02)+1)*26) * s * scaleMul;
      const w = (120 + (Math.cos(x*0.03)+1)*38) * s * scaleMul;
      ctx.fillStyle = "rgba(0,0,0,1)";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w*0.15, y - h*0.55);
      ctx.lineTo(x + w*0.35, y - h*0.35);
      ctx.lineTo(x + w*0.55, y - h*0.75);
      ctx.lineTo(x + w*0.78, y - h*0.30);
      ctx.lineTo(x + w, y - h*0.52);
      ctx.lineTo(x + w, y + h*0.15);
      ctx.lineTo(x, y + h*0.15);
      ctx.closePath();
      ctx.fill();
    }

    function drawRoad(){
      const s = world.scale;
      const left = world.roadLeft;
      const right = world.roadRight;
      const top = world.horizonY;
      const bottom = H + 40*s;

      const grd = ctx.createLinearGradient(0, top, 0, bottom);
      grd.addColorStop(0, "rgba(18,20,36,1)");
      grd.addColorStop(0.55, "rgba(10,12,22,1)");
      grd.addColorStop(1, "rgba(6,7,12,1)");
      ctx.fillStyle = grd;

      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(right, top);
      ctx.lineTo(right + 130*s, bottom);
      ctx.lineTo(left - 130*s, bottom);
      ctx.closePath();
      ctx.fill();

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = "rgba(176,124,255,0.35)";
      ctx.lineWidth = 2*s;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(left - 130*s, bottom);
      ctx.moveTo(right, top);
      ctx.lineTo(right + 130*s, bottom);
      ctx.stroke();
      ctx.restore();

      const t = game.t;
      ctx.save();
      const stripes = 10;
      for(let i=0;i<stripes;i++){
        const z = ((i/stripes) + ((t*0.55)%1)) % 1;
        const y = lerp(top, bottom, z*z);
        const w = lerp(8*s, 46*s, z*z);
        const x = W*0.5 + Math.sin((t*0.8) + i)*2*s;
        ctx.globalAlpha = 0.10 + 0.10*(1-z);
        ctx.fillStyle = "rgba(47,230,255,1)";
        ctx.fillRect(x - w*0.5, y, w, 4*s);
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(0,0,0,1)";
      for(let i=0;i<60;i++){
        const px = rand(left-90*s, right+90*s);
        const py = rand(top, H);
        const r = rand(0.8, 2.2)*s;
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPortals(){
      const s = world.scale;
      const cx = W*0.5;
      const cy = world.horizonY - 28*s;
      const pulse = fx.portalPulse;
      const phase = fx.portalPhase;

      ctx.save();
      ctx.globalAlpha = 0.12 + 0.18*pulse;
      const r = (70 + 18*Math.sin(phase*1.5)) * s;
      const rg = ctx.createRadialGradient(cx, cy, r*0.15, cx, cy, r*1.2);
      rg.addColorStop(0, "rgba(47,230,255,0.55)");
      rg.addColorStop(0.35, "rgba(176,124,255,0.32)");
      rg.addColorStop(0.75, "rgba(15,25,40,0.05)");
      rg.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(cx, cy, r*1.15, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.18 + 0.24*pulse;
      ctx.strokeStyle = "rgba(176,124,255,0.65)";
      ctx.lineWidth = 2*s;
      ctx.beginPath();
      for(let i=0;i<40;i++){
        const a = (i/40)*Math.PI*2 + phase*0.7;
        const rr = r*(0.78 + 0.12*Math.sin(phase*2 + i));
        const x = cx + Math.cos(a)*rr;
        const y = cy + Math.sin(a)*rr*0.74;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.stroke();

      ctx.globalAlpha = 0.08 + 0.10*pulse;
      ctx.strokeStyle = "rgba(47,230,255,0.65)";
      ctx.lineWidth = 1.5*s;
      ctx.beginPath();
      for(let i=0;i<56;i++){
        const a = (i/56)*Math.PI*2 - phase*0.9;
        const rr = r*(0.52 + 0.10*Math.sin(phase*2.4 + i*0.7));
        const x = cx + Math.cos(a)*rr;
        const y = cy + Math.sin(a)*rr*0.54;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.stroke();

      ctx.restore();
    }

    function drawEntitiesLayered(){
      const all = [];
      for(const e of entities.obstacles) all.push(e);
      for(const e of entities.items) all.push(e);
      for(const e of entities.enemies) all.push(e);
      for(const e of entities.hazardFX) all.push(e);

      all.sort((a,b)=> (a.y - b.y));

      for(const e of all){
        if(e.type === "obstacle") drawObstacle(e);
        else if(e.type === "item") drawItem(e);
        else if(e.type === "enemy") drawEnemy(e);
        else if(e.type === "hazard") drawHazard(e);
      }
    }

    function drawShadow(x,y,w,h,alpha){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.beginPath();
      ctx.ellipse(x, y + h*0.38, w*0.55, h*0.20, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawObstacle(e){
      const s = world.scale;
      const depth = clamp((e.y - world.horizonY) / (world.groundY - world.horizonY), 0, 1);
      const ps = lerp(0.58, 1.12, easeOutCubic(depth));
      const x = e.x, y = e.y;
      const w = e.w * ps, h = e.h * ps;

      drawShadow(x, y, w, h, 0.25 + 0.25*depth);

      if(e.kind === "spike"){
        ctx.save();
        ctx.globalAlpha = 0.92;
        const gx = ctx.createLinearGradient(x-w*0.5, y-h*0.5, x+w*0.5, y+h*0.5);
        gx.addColorStop(0, "rgba(60,70,95,1)");
        gx.addColorStop(0.55, "rgba(22,26,40,1)");
        gx.addColorStop(1, "rgba(130,90,210,1)");
        ctx.fillStyle = gx;
        ctx.beginPath();
        ctx.moveTo(x-w*0.5, y+h*0.45);
        ctx.lineTo(x-w*0.2, y-h*0.45);
        ctx.lineTo(x, y+h*0.10);
        ctx.lineTo(x+w*0.2, y-h*0.45);
        ctx.lineTo(x+w*0.5, y+h*0.45);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 0.28;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s;
        ctx.stroke();
        ctx.restore();
      }

      if(e.kind === "wall"){
        ctx.save();
        ctx.globalAlpha = 0.92;
        const gx = ctx.createLinearGradient(x-w*0.5, y-h*0.5, x+w*0.5, y+h*0.5);
        gx.addColorStop(0, "rgba(42,50,72,1)");
        gx.addColorStop(0.55, "rgba(18,20,30,1)");
        gx.addColorStop(1, "rgba(78,54,130,1)");
        ctx.fillStyle = gx;
        roundRect(x-w*0.5, y-h*0.5, w, h, 10*s*ps);
        ctx.fill();
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = "rgba(176,124,255,1)";
        ctx.lineWidth = 2*s;
        ctx.stroke();
        ctx.globalAlpha = 0.18;
        for(let i=0;i<4;i++){
          ctx.fillStyle = "rgba(0,0,0,1)";
          ctx.fillRect(x-w*0.42 + i*w*0.24, y-h*0.42, w*0.06, h*0.84);
        }
        ctx.restore();
      }

      if(e.kind === "rock"){
        ctx.save();
        ctx.globalAlpha = 0.95;
        const rr = Math.min(w,h)*0.35;
        const gx = ctx.createRadialGradient(x-w*0.2, y-h*0.2, rr*0.2, x, y, rr*2.2);
        gx.addColorStop(0, "rgba(70,78,96,1)");
        gx.addColorStop(0.45, "rgba(18,20,30,1)");
        gx.addColorStop(1, "rgba(120,80,210,1)");
        ctx.fillStyle = gx;
        ctx.beginPath();
        ctx.moveTo(x-w*0.42, y+h*0.10);
        ctx.lineTo(x-w*0.18, y-h*0.46);
        ctx.lineTo(x+w*0.26, y-h*0.32);
        ctx.lineTo(x+w*0.46, y+h*0.18);
        ctx.lineTo(x+w*0.10, y+h*0.46);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s;
        ctx.stroke();
        ctx.restore();
      }

      if(e.kind === "vine"){
        ctx.save();
        ctx.globalAlpha = 0.92;
        const gx = ctx.createLinearGradient(x-w*0.5, y, x+w*0.5, y);
        gx.addColorStop(0, "rgba(20,30,28,1)");
        gx.addColorStop(0.5, "rgba(12,16,18,1)");
        gx.addColorStop(1, "rgba(47,230,255,1)");
        ctx.strokeStyle = gx;
        ctx.lineWidth = 9*s*ps;
        ctx.lineCap = "round";
        ctx.beginPath();
        const wig = Math.sin((game.t*3.0)+e.phase)*10*s*ps;
        ctx.moveTo(x-w*0.45, y-h*0.1);
        ctx.bezierCurveTo(x-w*0.15, y-h*0.55+wig, x+w*0.15, y+h*0.55-wig, x+w*0.45, y+h*0.05);
        ctx.stroke();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = "rgba(176,124,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawEnemy(e){
      const s = world.scale;
      const depth = clamp((e.y - world.horizonY) / (world.groundY - world.horizonY), 0, 1);
      const ps = lerp(0.62, 1.15, easeOutCubic(depth));
      const x = e.x, y = e.y;
      const w = e.w * ps, h = e.h * ps;

      drawShadow(x, y, w, h, 0.22 + 0.30*depth);

      if(e.kind === "shadowElite"){
        ctx.save();
        ctx.globalAlpha = 0.95;
        const gx = ctx.createRadialGradient(x, y-h*0.2, 2, x, y, w);
        gx.addColorStop(0, "rgba(176,124,255,0.55)");
        gx.addColorStop(0.35, "rgba(15,15,20,1)");
        gx.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = gx;
        roundRect(x-w*0.34, y-h*0.56, w*0.68, h*0.86, 14*s*ps);
        ctx.fill();
        ctx.globalAlpha = 0.18 + 0.20*Math.sin(game.t*6 + e.phase);
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.stroke();
        ctx.globalAlpha = 0.32;
        ctx.fillStyle = "rgba(47,230,255,1)";
        ctx.beginPath();
        ctx.arc(x-w*0.12, y-h*0.20, 3*s*ps, 0, Math.PI*2);
        ctx.arc(x+w*0.12, y-h*0.20, 3*s*ps, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if(e.kind === "wraith"){
        ctx.save();
        const bob = Math.sin(game.t*4.2 + e.phase) * 8*s*ps;
        ctx.globalAlpha = 0.88;
        const rg = ctx.createRadialGradient(x, y-h*0.15 + bob, 4, x, y + bob, w*0.85);
        rg.addColorStop(0, "rgba(47,230,255,0.35)");
        rg.addColorStop(0.45, "rgba(15,18,25,0.95)");
        rg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.ellipse(x, y + bob, w*0.44, h*0.56, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = "rgba(176,124,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.beginPath();
        ctx.ellipse(x, y + bob, w*0.44, h*0.56, 0, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      if(e.kind === "vortexOrb"){
        ctx.save();
        const spin = game.t*2.6 + e.phase;
        ctx.globalAlpha = 0.95;
        const rg = ctx.createRadialGradient(x, y, 2, x, y, w*0.75);
        rg.addColorStop(0, "rgba(47,230,255,0.65)");
        rg.addColorStop(0.35, "rgba(176,124,255,0.38)");
        rg.addColorStop(0.70, "rgba(10,12,18,0.95)");
        rg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x, y, w*0.42, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 0.26;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.beginPath();
        for(let i=0;i<34;i++){
          const a = (i/34)*Math.PI*2 + spin;
          const rr = w*0.42*(0.45 + 0.55*Math.sin(spin*1.4 + i));
          const xx = x + Math.cos(a)*rr;
          const yy = y + Math.sin(a)*rr;
          if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.restore();
      }
    }

    function drawItem(e){
      const s = world.scale;
      const depth = clamp((e.y - world.horizonY) / (world.groundY - world.horizonY), 0, 1);
      const ps = lerp(0.60, 1.10, easeOutCubic(depth));
      const x = e.x, y = e.y;
      const w = e.w*ps, h = e.h*ps;

      drawShadow(x, y, w, h, 0.18 + 0.20*depth);

      ctx.save();
      const bob = Math.sin(e.phase*2.2) * 6*s*ps;
      const glow = 0.35 + 0.25*Math.sin(e.phase*3.0);

      if(e.kind === "rune"){
        ctx.globalAlpha = 0.92;
        const rg = ctx.createRadialGradient(x, y+bob, 2, x, y+bob, w*0.9);
        rg.addColorStop(0, "rgba(176,124,255,0.85)");
        rg.addColorStop(0.45, "rgba(47,230,255,0.35)");
        rg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x, y+bob, w*0.45, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 0.26 + 0.12*glow;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.beginPath();
        ctx.moveTo(x-w*0.18, y+bob);
        ctx.lineTo(x, y-h*0.22+bob);
        ctx.lineTo(x+w*0.18, y+bob);
        ctx.lineTo(x, y+h*0.22+bob);
        ctx.closePath();
        ctx.stroke();
      }

      if(e.kind === "coin"){
        ctx.globalAlpha = 0.92;
        const rg = ctx.createRadialGradient(x-w*0.15, y-h*0.15+bob, 2, x, y+bob, w);
        rg.addColorStop(0, "rgba(255,232,140,0.95)");
        rg.addColorStop(0.50, "rgba(176,124,255,0.25)");
        rg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.ellipse(x, y+bob, w*0.36, h*0.36, Math.sin(e.phase)*0.7, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 0.24;
        ctx.strokeStyle = "rgba(255,232,140,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.stroke();
      }

      if(e.kind === "potion"){
        ctx.globalAlpha = 0.92;
        const body = ctx.createLinearGradient(x-w*0.2, y-h*0.2+bob, x+w*0.2, y+h*0.2+bob);
        body.addColorStop(0, "rgba(60,70,95,1)");
        body.addColorStop(0.45, "rgba(18,20,30,1)");
        body.addColorStop(1, "rgba(255,77,77,0.95)");
        ctx.fillStyle = body;
        roundRect(x-w*0.22, y-h*0.18+bob, w*0.44, h*0.58, 10*s*ps);
        ctx.fill();
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = "rgba(255,77,77,1)";
        roundRect(x-w*0.16, y-h*0.02+bob, w*0.32, h*0.34, 8*s*ps);
        ctx.fill();
        ctx.globalAlpha = 0.20;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.stroke();
        ctx.globalAlpha = 0.65;
        ctx.fillStyle = "rgba(220,230,245,0.85)";
        roundRect(x-w*0.10, y-h*0.30+bob, w*0.20, h*0.14, 6*s*ps);
        ctx.fill();
      }

      if(e.kind === "timeRelic"){
        ctx.globalAlpha = 0.92;
        const rg = ctx.createRadialGradient(x, y+bob, 2, x, y+bob, w);
        rg.addColorStop(0, "rgba(47,230,255,0.95)");
        rg.addColorStop(0.40, "rgba(176,124,255,0.35)");
        rg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(x, y+bob, w*0.44, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 0.22 + 0.12*glow;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s*ps;
        ctx.beginPath();
        ctx.arc(x, y+bob, w*0.30, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y+bob);
        ctx.lineTo(x + Math.cos(e.phase*2.6)*w*0.22, y+bob + Math.sin(e.phase*2.6)*w*0.22);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawHazard(h){
      const s = world.scale;
      const depth = clamp((h.y - world.horizonY) / (world.groundY - world.horizonY), 0, 1);
      const ps = lerp(0.60, 1.14, easeOutCubic(depth));
      const x = h.x, y = h.y;
      const w = h.w*ps, hh = h.h*ps;

      drawShadow(x, y, w, hh, 0.18 + 0.18*depth);

      ctx.save();
      ctx.globalAlpha = 0.72 * h.alpha;
      const rg = ctx.createRadialGradient(x, y, 2, x, y, w);
      rg.addColorStop(0, "rgba(47,230,255,0.55)");
      rg.addColorStop(0.35, "rgba(176,124,255,0.38)");
      rg.addColorStop(0.85, "rgba(10,12,18,0.95)");
      rg.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(x, y, w*0.46, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.18 * h.alpha;
      ctx.strokeStyle = "rgba(47,230,255,1)";
      ctx.lineWidth = 2*s*ps;
      ctx.beginPath();
      ctx.arc(x, y, w*0.46, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      const s = world.scale;
      const x = player.x, y = player.y;
      const w = player.w, h = player.h;

      drawShadow(x, y, w, h, 0.36);

      ctx.save();
      let alpha = 1;
      if(player.invul > 0){
        alpha = 0.55 + 0.35*Math.sin(game.t*18);
      }
      if(player.dodgeT > 0){
        alpha *= 0.80;
      }
      ctx.globalAlpha = alpha;

      const haloA = (player.dodgeT>0 ? 0.30 : 0.12) + player.aura*0.7;
      ctx.globalAlpha = haloA;
      const rg = ctx.createRadialGradient(x, y-h*0.2, 2, x, y, w*1.4);
      rg.addColorStop(0, "rgba(176,124,255,0.65)");
      rg.addColorStop(0.40, "rgba(47,230,255,0.18)");
      rg.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(x, y, w*1.15, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = alpha;

      const body = ctx.createLinearGradient(x-w*0.4, y-h*0.6, x+w*0.4, y+h*0.5);
      body.addColorStop(0, "rgba(70,80,105,1)");
      body.addColorStop(0.45, "rgba(15,18,28,1)");
      body.addColorStop(1, "rgba(176,124,255,0.85)");
      ctx.fillStyle = body;
      roundRect(x-w*0.28, y-h*0.56, w*0.56, h*0.92, 14*s);
      ctx.fill();

      ctx.globalAlpha = alpha*0.25;
      ctx.strokeStyle = "rgba(47,230,255,1)";
      ctx.lineWidth = 2*s;
      ctx.stroke();

      ctx.globalAlpha = alpha*0.85;
      ctx.fillStyle = "rgba(220,230,245,0.85)";
      roundRect(x-w*0.18, y-h*0.52, w*0.36, h*0.20, 10*s);
      ctx.fill();

      ctx.globalAlpha = alpha*0.22;
      ctx.fillStyle = "rgba(0,0,0,1)";
      for(let i=0;i<4;i++){
        ctx.fillRect(x-w*0.20 + i*w*0.10, y-h*0.24, w*0.05, h*0.60);
      }

      if(player.dodgeT > 0){
        ctx.globalAlpha = 0.22;
        ctx.strokeStyle = "rgba(176,124,255,1)";
        ctx.lineWidth = 3*s;
        ctx.beginPath();
        ctx.arc(x, y-h*0.10, w*0.55, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawFX(){
      const s = world.scale;

      for(const f of fx.flashes){
        const t = clamp(f.age / f.t, 0, 1);
        const r = lerp(f.r0, f.r1, easeOutCubic(t));
        const a = (1 - t) * 0.30;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.strokeStyle = "rgba(47,230,255,1)";
        ctx.lineWidth = 2*s;
        ctx.beginPath();
        ctx.arc(f.x, f.y, r, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = a*0.6;
        ctx.strokeStyle = "rgba(176,124,255,1)";
        ctx.beginPath();
        ctx.arc(f.x, f.y, r*0.70, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      for(const p of fx.particles){
        ctx.save();
        const t = clamp(p.age/p.life, 0, 1);
        const a = (1 - t) * 0.9;
        const glow = p.glow;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.globalAlpha = a;
        if(p.kind === 0){
          ctx.fillStyle = `rgba(176,124,255,${0.85})`;
        }else if(p.kind === 1){
          ctx.fillStyle = `rgba(47,230,255,${0.85})`;
        }else if(p.kind === 2){
          ctx.fillStyle = `rgba(255,77,77,${0.80})`;
        }else{
          ctx.fillStyle = `rgba(0,0,0,${0.65})`;
        }
        roundRect(-p.size*0.5, -p.size*0.5, p.size, p.size, Math.max(2, p.size*0.25));
        ctx.fill();
        ctx.globalAlpha = a * glow * 0.45;
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        roundRect(-p.size*0.25, -p.size*0.25, p.size*0.5, p.size*0.5, Math.max(2, p.size*0.22));
        ctx.fill();
        ctx.restore();
      }
    }

    function drawVignette(){
      ctx.save();
      const v = fx.vignette;
      const rg = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.10, W*0.5, H*0.55, Math.max(W,H)*0.62);
      rg.addColorStop(0, "rgba(0,0,0,0)");
      rg.addColorStop(0.55, `rgba(0,0,0,${v*0.28})`);
      rg.addColorStop(1, `rgba(0,0,0,${v})`);
      ctx.fillStyle = rg;
      ctx.fillRect(0,0,W,H);

      if(player.invul > 0){
        const a = clamp(player.invul/0.9, 0, 1) * 0.25;
        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(255,77,77,1)";
        ctx.fillRect(0,0,W, H);
      }
      ctx.restore();
    }

    function roundRect(x,y,w,h,r){
      const rr = Math.min(r, w*0.5, h*0.5);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function updateUI(){
      uiScore.textContent = String(Math.floor(game.score));
      uiTime.textContent = `${fmt1(game.t)}s`;
      uiLevel.textContent = String(game.lvl);
      uiCombo.textContent = game.comboPlaceholder;
    }

    function handleControls(){
      if(input.pause){
        input.pause = false;
        audio.resume();
        if(!game.started){
          game.started = true;
          game.paused = false;
          game.gameOver = false;
          resetRun();
          hidePanel();
          toastMsg("룬도주 시작");
          audio.portal();
          a11yAnnounce.textContent = "게임 시작";
        }else if(game.gameOver){
          game.restart();
        }else{
          game.setPaused(!game.paused, game.paused ? "" : "일시정지");
        }
      }
      if(input.restart){
        input.restart = false;
        game.restart();
      }
    }

    let lastT = 0;
    function tick(ts){
      if(!lastT) lastT = ts;
      let dt = (ts - lastT) / 1000;
      lastT = ts;
      dt = clamp(dt, 0, 0.05);

      handleControls();

      if(game.started && !game.paused && !game.gameOver){
        game.t += dt;
        updateDifficulty(dt);

        const baseScore = game.t * 10;
        const s = Math.floor(baseScore);
        const itemScore = game.score - Math.floor(game.score - (game.score - Math.floor(game.score)));
        game.score = Math.max(game.score, baseScore);
        game.score = Math.max(game.score, baseScore) + 0;
        game.score = baseScore + (game.score - baseScore);

        updatePlayer(dt);
        updateSpawns(dt);
        updateEntities(dt);
        updateFX(dt);

        if(game.t > 0.01){
          game.score = (game.t * 10) + (game.score - (game.t * 10));
        }

        if(game.score < game.t*10) game.score = game.t*10;

        if(game.hp > 0){
          if(Math.random() < 0.004 + (spawner.difficulty-1)*0.002){
            const cx = W*0.5 + rand(-40,40)*world.scale;
            const cy = world.horizonY + rand(-20, 40)*world.scale;
            fx.spawnBurst(cx, cy, randi(3,6), Math.random()<0.5?0:1);
          }
        }
      }else{
        updateFX(dt*0.6);
        updatePlayer(dt*0.4);
      }

      if(game.gameOver){
        updateBest();
      }

      updateUI();
      draw();

      requestAnimationFrame(tick);
    }

    function boot(){
      resize();
      game.best = storage.get("rundoju_best", 0) || 0;
      uiBest.textContent = String(game.best);
      resetRun();
      showPanel("intro");
      audio.setMuted(false);
      requestAnimationFrame(tick);
    }

    window.addEventListener("pointerdown", () => audio.resume(), { passive:true });

    boot();
  </script>
</body>
</html>
